# 02. Operating System

만든이 : [🍀] 최보윤, [🦔] 정민지, [🍺]이시화, [😎] 박귀우, [😠] 한규빈, [🐰] 김란, [🌱] 서주원, [:sparkling_heart:] 김우진
</br></br>

# 운영체제 개념

#### 🍀 운영체제란 무엇인가?

- 운영체제란 프로그램 실행시 필요한 하드웨어 단에서의 작업을 처리해주며 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며, 시스템의 동작을 제어하는 시스템 소프웨어입니다.
  </br></br>

# 커널과 쉘

#### 🍀 프로그램이 실행되는 동안 사용자 모드와 커널모드는 어떻게 동작하는가?

- 프로세스는 두 모드 중 하나의 모드만을 가지는 것이 아니라 프로그램이 실행되는 동안 수없이 사용자 모드와 커널 모드를 반복하면서 실행됩니다. </br>
  프로세스가 사용자 모드에서 작업을 수행하다 하드웨어 접근, 보안 과 같은 중요 명령을 수행해야 될 때면 시스템 콜을 호출합니다. 그럼 커널 모드로 전환되며 필요한 커널 함수를 호출하여 연산을 수행합니다. 연산이 모두 완료되면 경우에 따라 결과값과 함게 사용자 모드로 전환되어 다시 프로그램의 작업을 수행하게 됩니다.
  </br></br>

#### 🍺 쉘의 기능과 종류

- 쉘의 기능

  사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램, 쉘도 하나의 응용 프로그램 </br>

- 쉘의 종류

  1. Bourne Shell

  - 벨 연구소의 스티브본 (Stephen Bourne) 개발, 많은 셸 스크립트의 기반이 되는 쉘
    </br></br>

  2. C Shell

  - C언어 구문과 유사, Bourne Shell 을 확장하여 히스토리, 작업제어, 엘리어스 등 기능 추가 개발자들에게 유용한 기능들을 제공한다.
    </br></br>

  3.  TC Schell

  - C Shell 에 명령 행 완성 과 명령 행 편집 기능을 추가
    </br></br>

  4. Korn Shell

  - Bourne Shell 가 호환되며 C Shell 의 많은 기능을 포함, Unix 계열에서 많이 사용된다.
    </br></br>

  5. Bourne Again Shell (bash)

  - 리눅스에서 가장많이 사용되는 쉘로 Bourne 셀을 토대로 C셸과 Korn Shell 의 기능들을 통합시켜 개발되었다.
    </br></br>

# 프로세스와 스레드

#### 🦔 PCB(Process Control Block)란 무엇인가?

- <strong>프로세스의 상태 정보를 저장</strong>하는 공간이다. </br> A 프로세스가 수행되다 B 프로세스로 넘어가고 다시 A 프로세스로 돌아와 이전에 하던 작업을 수행할 때 이전에 A 프로세스가 수행되고 있었다는 사실을 어떻게 알 수 있을까? 그 정보가 담겨있는 공간이 바로 PCB이다. 프로세스가 생성될 때 만들어진다. PCB에는 해당 프로세스의 고유 번호, 상태, 다음에 실행될 프로세스 포인터, 자원 정보, 입출력 상태 정보 등이 들어가있다. 작업 관리자를 열면 나와있는 PID! 이것이 PCB에 저장되어 있는 프로세스 고유 번호이다.
  </br></br>

#### 🍺 프로세스 핵심 시스템 콜 fork()

- <strong>fork()란 함수는 현재 프로세스에 대해 자식 프로세스를 생성하는 함수이다.</strong></br>특히 유닉스 환경 서버 측에서 프로세스를 생성할 때 fork() 함수를 필수적으로 사용
- 예시</br>
  - <strong>서버</strong></br>
서버는 하나의 서비스 내에서 여러 개의 클라이언트를 받아내야 함.
그래서 서버의 프로세스가 클라이언트의 요청을 받으면 자신이 응답하는 것이 아니라, 자식을 fork 하여 전달. 즉, 서버 프로세스가 접속을 받을 때마다 요청을 처리할 프로세스를 fork 로 생성하여 응답
  - <strong>OS</strong></br>
운영체제에선 동작중인 프로그램 외에도 다른 프로그램을 동작시켜야 할 때
새로운 프로세스를 생성해야 함. 그 방법으로 프로세스 자신을 fork 함수 복제하여 프로그램을 호출. 복제한 자식 프로세스와 통신은 IPC 를 이용하여 함.

#### 😠 프로세스의 구조
- 프로세스의 구조는 크게 CODE, DATA, HEAP, STACK 4가지의 영역이 있음
- 작성한 코드를 컴파일하면 바이너리 코드(실행파일)이 만들어 짐
- 바이너리 코드를 실행하면 프로세스 CODE 영역에는 바이너리 코드가 저장 됨
- DATA 영역에는 전역 변수, 초기화된 변수가 저장 됨
- HEAP 영역에는 코드에서 동적으로 생성되는 데이터(자바에서는 객체)가 저장 됨
- STACK 영역에는 메서드 로컬 변수 등이 저장 됨
- 프로세스 구조 이미지
<img width="334" alt="스크린샷 2022-06-12 오전 11 53 17" src="https://user-images.githubusercontent.com/67041069/173212362-3f9bfd2a-7f22-4ef8-854f-15ec3a5a0c98.png">


  </br></br>

#### 🍀 Mode Switching 과 Context Switching의 차이점은 무엇인가?

- Mode Switching : 사용자 모드와 커널 모드 간의 스위칭 과정을 뜻하는 것으로 Mode Switching이 발생하면 현재 프로세스의 상태를 저장하고, PC를 다음 작업을 할 주소값으로 세팅해 커널 모드로 전환합니다.
- Context Switching은 프로세스의 상태를 변화시키는 스위칭 과정을 뜻하는 것으로 Context Switching이 발생하면 진행중인 프로세스의 상태를 기록하고, 불러오는 프로세스의 이전 상태를 복원하고 또한 각 프로세스를 저장할 큐의 메모리 위치를 선점 하는 등의 좀 더 복잡한 작업을 진행합니다.
- 일반적으로 Mode Switching이 발생되면 상황에 따라 Context Switching이 발생하는 구조입니다. 인터럽트, Exception, 시스템 콜 등이 일어나 Mode Switching이 발생하고 그에 따라서 프로세스의 상태가 변화가 필요하면 Context Switching이 발생합니다.
  </br></br> 


#### 🦔 IPC란 무엇이며 왜 필요한가?

- IPC란 Inter-Process Communication, 프로세스 간의 통신을 뜻한다. </br>IPC 기법은 굉장히 다양하게 존재하는데 대표적인 기법으로는 메세지 큐, 쉐어드 메모리, 파이프 등이 있다. 이 기법들은 모두 커널 공간을 사용하는데 프로세스는 커널 공간은 공유할 수 있기 때문이다. 예를 들어 커널 공간에 메모리 공간을 만들고 해당 공간을 변수처럼 쓰는 식이다. </br> 그렇다면 왜 필요할까? 멀티 코어의 등장으로 성능을 높이기 위해 하나의 프로그램을 여러 프로세스로 나누어 처리하게 되었다. </br>이로 인해 프로세스 간의 통신이 필요한 경우가 생기는데 프로세스는 서로 공간이 완전히 분리되어 있기 때문에 그 자체로는 서로 통신이 불가능하다. 그로 인해 프로세스 간의 통신을 도와주는 IPC가 나오게 되었다.
  </br></br>

#### 🌱 Thread vs Process

- 프로세스는 독립적, 스레드는 프로세스의 서브넷
- 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유
  - 하나의 프로세스 안에 여러 스레드가 있을 때, stack을 제외한 code, data, heap을 공통된 자원으로 사용한다.
- 프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유
- 프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요 없음
  </br></br>

#### 🍀 스레드의 장단점은 무엇인가?

- 스레드의 장점
  - 일부 스레드의 처리가 지연되더라도 다른 스레드에서 작업을 계속해서 처리할 수 있어 성능 및 응답성이 향상된다.
  - 프로세스 간의 통신은 IPC가 필요하지만 스레드는 프로세스 내에 존재하여 자원을 공유하기 때문에 자원 할당 비용이나 문맥 교환 비용이 적게 든다.
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 관리할 수 있다
  - 코드의 간결성을 유지할 수 있다
- 스레드의 단점
  - 하나의 스레드에서 문제가 발생하면 프로세스 전반에 영향을 미칠 수 있다.
  - 다중 스레드를 생성하면 Contest Switching이 빈번히 발생해 성능 저하를 일으킬 수 있다.
  - 프로세스 내의 자원을 공유하기 때문에 동기화 문제가 발생할 수 있다.
    </br></br>

# 스케줄링

#### 🦔 멀티 태스킹, 멀티 프로그래밍의 차이는 무엇인가?

- 구현에 있어서는 유사한 측면이 있지만 각자 다른 목적을 가지고 있다. </br>
  멀티 태스킹은 단일 CPU에서 여러 프로그램이 굉장히 빠르게 교대로 실행하는 방식이며 이것을 통해 사용자에게 이것이 마치 동시에 이루어지고 있다는 느껴지게 하는 목적을 가졌다.
  멀티 프로그래밍은 응용 프로그램이 시분할 방식을 통해 처리되는 과정에서 CPU가 아닌 입출력 장치나 저장 매체 등을 이용할 때 그 시간 동안 다른 응용 프로그램을 실행하는 방식이며 </br> CPU의 사용을 최대화하는 목적을 가졌다. 프로세서의 자원 낭비를 최소화한다. </br>
  멀티 태스킹은 동시에 여러 프로그램이 돌아가는 것처럼 보여주는 것이고 멀티 프로그래밍은 CPU를 쉬지 않고 일하게 하는 것이다.
  </br></br>

#### 🍀 스케줄러란 무엇이며 스케줄러의 종류에는 무엇이 있는가?

- 스케줄러란 어떤 프로세스에 자원을 할당할지 결정하는 운영체제의 커널 모듈로 장기 스케줄러, 중기 스케줄러, 단기 스케줄러가 있습니다.

  1. 장기 스케줄러는 메모리와 디스크 사이의 스케줄링을 담당하는 스케줄러로 풀(pool)로부터 프로세스들을 선별하여 실행시키기 위해 메모리에 적재하는 역할을 합니다.
  2. 단기 스케줄러는 Dispatcher가 메모리에 적재되어 실행이 준비된 프로세스들 중 하나를 선택하여 CPU에 할당하는 역할을 합니다. 현재의 개념은 가상 메모리 개념이기 때문에 장기, 중기 스케줄러가 실제 운영체제에 사용되지 않아 일반적으로 스케줄러라 부르는 것은 단기 스케줄러를 의미합니다.
  3. 중기 스케줄러는 어떤 프로세스들이 CPU를 할당받을 것인지를 결정지어 프로세스들을 중재하여 일시적으로 보류하고 재활성화 하는 역할을 합니다.
     </br></br>

#### 🍺 스케쥴러의 종류

1. FIFO<br>
   가장 간단한 스케쥴러 먼저 온 순서대로 처리
   배치 처리 시스템

2. Round Robin<br>
   FIFO 구조에서 원형으로 돌아가는 시스템
   시분할 시스템

3. SJF<br>
   최단 작업 스케쥴러로 실행 시간이 가장 짧은 프로세스 부터 먼저 실행
   실제 프로세스가 정확히 얼마나 걸리는지 알 수 있는 곳에서 사용(반도체 fab)

4. 우선순위 기반 스케쥴링<br>
   프로세스에 우선순위를 두고 실행하는 스케쥴링
   정적 우선순위, 동적우선순위가 존재
   </br></br>


#### 🌱 프로세서 스케줄링에서 비선점 스케줄링을 설명하세요.
- 비선점 스케줄링은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법을 의미합니다. 따라서 프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU를 사용하여 응답시간 예측이 용이하고, 모든 프로세스에 대한 요구를 공정하게 처리  가능합니다. 때문에 일괄처리 방식에 적합하지만, 중요한 작업이 기다리는 경우가 발생할 수 있습니다.

- 종류로는 FCFS, SJF, 우선순위, HRN, 기한부 등 알고리즘이 있습니다.
</br></br>

#### 🌱 프로세서 스케줄링에서 선점 스케줄링을 설명하세요.
- 선점 스케줄링은 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법입니다. 따라서 우선순위가 높은 프로세스를 빠르게 처리할 수 있고, 주로 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용합니다. 하지만 선점으로 인한 많은 오버헤드를 초래하며, 선점을 위해 시간 배당을 위한 인터럽트용 타이머 클럭이 필요합니다.

- 종류로는 SRT, 선점 우선순위, RR(Round Robin), 다단계 큐, 다단계 피드백 큐 등 알고리즘이 있습니다.


# 동기화

#### 🐰 동기화란 무엇이며 해결 방안으로는 무엇이 있는가?

- 동기화(Syncronization)란 작업들 사이에 실행 시기를 맞추는 것을 말한다.
- 동기화 이슈는 여러 스레드가 동일한 데이터에 접근했을 때 발생하는 오류를 뜻한다.
- 동기화 이슈 해결 방안들
  1. Mutual exclusion(상호 배제): 임계영역(critical resource를 동시에 읽고 쓸 수 없도록 하는 부분)을 locking한다.
     Mutex(binary semaphore): 임계 구역에 하나의 스레드만 들어가도록 허용한다.
     Semaphore: 임계 구역에 여러 스레드가 들어갈 수 있다. counter를 이용하여 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어한다.
  2. 스레드는 프로세스의 모든 데이터에 접근 가능하므로 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access가 필요하다.
     즉, 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 접근하지 못하도록 막는다.
     </br></br>

#### 🍀 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이는 무엇인가?

- 뮤텍스는 이진 세마포어(Binary Semaphore)로 세마포어의 일종입니다. 뮤텍스와 세마포어의 가장 큰 차이점으로는 공유 자원에 접근할 수 있는 대상의 개수 차이입니다. 뮤텍스는 오직 1개의 프로세스 혹은 스레드만 공유 자원에 접근 할 수 있는 반면에 세마포어는 지정된 변수의 값만큼 접근할 수 있습니다. 또한 뮤텍스는 자원을 점유하는 대상이 락의 권한을 가지고 있는 반면에 세마포어는 운영체제, 커널 단위에서 해당 리소스 변수가 관리되어 현재 자원을 점유중인 대상의 잠금 상태를 관리 할 수 있습니다. 세마포어는 추가적으로 다른 프로세스 및 스레드의 잠금 상태를 관리 할 수 있습니다.
  </br></br>

# 교착상태

#### 😎 은행송금 시스템 관리를 위해 동시성 프로그래밍을 위해 스레드를 이용하기로 하였다. **데드락** 상황 이 될수 있는경우 와 이를 예방하기위한 방법을 설명하세요.

- 각각의 계좌 스레드 에서 잔고 의 예금을 얻기위해 서로 의 결과를 기다리고 있는 상태가 무한히 지속된다면 데드락 상황이 된다

- [**문제상황 만들기**]

  - 계좌 객체 2개가 있다 각 각의 계좌는 송금 입금등의 계좌 관리 메소드가 있고,
  - 송금 객체 에는 스레드 생성을 위한 함수가 구현이 되어있다.
  - 송금 하는 과정 을 예로들어 A계좌 에서 B, B계좌에서 A 계좌로 송금을 진행한다고 하면,우리는 각 계좌의 잔고 보호를 위해 계좌 뮤텍스화 시켜 컨텍스트 스위칭으로 부터 계좌의 잔고를 보호할것이다. 송금계좌 를 락 시키고 송금이진행되는 과정중 입금받는 계좌 또한 락을 걸어 잔고의 보호를 진행한다.

- [**Case 1**]

  - a계좌의 송금 과 b계좌의 예금이 순서대로 진행되고 b계좌의 송금과 a계좌의 예금이 진행된다.

- [**Case 2**]

  - a계좌 의 송금이 진행되며 a 계좌 객체는 뮤텍스 에 의해 락이 된다. 이떄 서버로 부터 계좌의 업데이트를 받기 위해 잠시 대기하는동안 컨텍스트 스위칭이 진행되고, b계좌의 송금이 진행된다. 이떄 b 계좌 또한 락이 발생한다. 서로 락이 된 객체 를 하염없이 기다리는 상황이 발생

- [**해결방안**] - 뮤텍스 의 단계를 각각 나눠준다.
  즉 송금 하는 과정 의 전부 를 뮤텍스 화 시키는 것이 아닌 A계좌의 뮤텍스 그후 B계좌의 뮤텍스 이렇게 각각 나누어 진행한다.
  데드락 없이 하나의 송금 프로그램이 종료되면 자연스럽게 락이 풀리며 다음 송금 프로그램이 진행된다.
  <br/>

#### :sparkling_heart: 교착상태란 무엇인가?

- DEADLOCK
- 무한대기 상태, 두 개 이상의 작업이 서로 상대방의 작업이 끝기만을 기다리고 있기 때문에 다음단계로 진행하지 못하는 단계
- 여러 프로세스가 동일자원 점유를 요청할 때 발생
  </br></br>

#### :sparkling_heart: 교착상태가 일어나는 조건?

- 상호배제(Mutual Exclusion) : 한번에 한개의 프로세스만이 공유 자원을 사용할 때, 사용 중인 자원을 다른 프로세스가 사용하기 위해 기다려야 한다.
- 점유와 대기(Hold and Wait) : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당 된 자원을 점유하기 위해 대기하는 프로세스가 있어야 한다.
- 비선점(Non-preemption) : 이미 할당 된 자원은 강제로 점유할 수 없음
- 환형 대기(Circular Wait) : 대기 프로세스의 집합이 순환형태로 대기하고 있어야 한다.

- 상기 4가지 조건이 동시에 성립될 때 교착상태, 즉 데드락상황이라고 할 수 있다.
  </br></br>

# 기아상태

#### 🌱 기아상태(starvation)

- 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 교착상태와 기아상태
  - 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
  - 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원이 할당이 안되는 경우를 주로 의미함
    </br></br>

#### 🌱 기아상태 해결 방안

- 우선순위 변경
  - 프로세스 우선순위를 수시로 변경해서, 각 프로세스가 높은 우선순위를 가질 기회주기
  - 오래 기다린 프로세스의 우선순위를 높여주기
  - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용
    </br></br>

# 메모리 관리 전략

#### 🌱 메모리 관리 전략은 무엇인가요?
 - 메모리 용량이 증가함에 따라 프로그램의 크기 또한 증가 하고 있어, 메모리는 언제나 부족합니다 이러한 제한된 물리 메모리의 효율적인 사용과 메모리 참조 방식을 제공하기 위한 전략을 메모리 관리 전략이라고 합니다.
 </br></br>

 #### 🌱 효율적인 메모리 사용은 무엇인가요?
 - 효율적인 메모리 사용은 메모리 낭비를 방지하는 것으로 3가지 방법이 있습니다.
   - 동적 적재 : 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재하는 기법입니다.
   - 동적 연결 : 라이브러리 루틴연결을 컴파일 시점에 하는 것이 아닌 실행 시점까지 미루는 기법 입니다.
   - 스와핑 : CPU에서 실행중이지 않는 프로세스는 저장장치의 swap 영역으로 이동해 메모리를 확보합니다, 이는 문맥 교환으로 인한 오버해드가 발생할 수 있고 속도가 느려지지만, 메모리 공간 확보에는 효율적입니다.

</br></br>

# 페이징

#### 🌱 페이징을 설명해 주세요.
 - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용 하고, 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리 하는 것을 페이징 이라고 합니다. 
  - 예) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
- 리눅스에서는 4KB로 paging
  </br></br>

#### 🍀 내부 단편화와 외부 단편화를 각각 무엇인가?

- 내부 단편화란 주기억장치 내 사용자 영역이 실행 프로그램보다 크지만 프로그램의 사용 공간을 할당 후 다른 작업들에 사용될만큼 크지 못해 빈공간으로 남게 되는 현상을 말합니다. 반대로 외부 단편화란 주기억장치 내에 남아있는 총 메모리 공간이 요청된 작업의 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 작업이 공간을 할당받지 못할 때 발생하는 현상을 말합니다.
  </br></br>

# 가상 메모리

#### 🦔 MMU에서 가상 메모리를 실제 메모리 주소로 변환할 때의 과정을 설명하라.

- 1. MMU에 가상주소가 전달되면 우선 TLB에서 해당 정보를 검색하게 된다. 만약 해당 가상 주소에 대한 정보(캐시)가 TLB에서 검색된다면 곧바로 물리적 주소를 리턴하고, </br>
  2. TLB가 해당 목록을 가지고 있지 않다면 페이지 테이블을 검색하게 된다. 페이지 테이블에서 해당 가상 주소가 검색된다면 그 주소를 이용해 물리 주소로 변환한 뒤 메모리에 접근하며
     </br>이후 TLB에 해당 값을 추가하게 된다. 그러나 만약 페이지 테이블에서도 찾지 못할 경우 페이지 폴트가 발생하게 되는데 이 경우 </br>
  3. 디스크를 읽어 해당 정보를 검색하게 되며 이후 페이지 테이블과 TLB를 갱신한다.</br></br>
- - MMU란 Memory Management Unit의 약자로 CPU에 탑재되어 가상 주소를 실제 메모리 주소로 변환해주는 하드웨어 장치이고 </br> TLB는 Translation Lookaside Buffer의 약자로 자주 사용되는 가상 주소 -> 물리 주소 변환 정보를 저장하는 일종의 고속 캐시이다. </br>
    ![img](https://user-images.githubusercontent.com/101824840/172370931-e5a4233a-179e-4e1c-a989-fd22420fe562.gif)
    </br></br>

#### 🍀 가상 메모리는 왜 필요한가?

- 가상 메모리가 필요한 이유는
  1. 한정적인 물리적 메모리보다 더 큰 공간으로 구성이 가능해 메모리에 확장성을 부여해준다.
  2. 실제 메모리 공간은 OS에서 처리하며 모든 프로그램에는 동일한 메모리공간을 제공해준다.
  3. 메모리 단편화 등의 문제를 해결하여 메모리 할당과 관리에 효율적이다.
  4. 각각의 프로세스는 별도의 메모리 공간을 점유해 다른 프로세스의 메모리 공간을 참조할 수 없게 만들어 메모리 보호기능을 제공한다.
</br></br>

#### 🍀 페이지 폴트(Page Fault)란 무엇인가?

- 페이지 폴트란 가상 메모리 주소를 통해서 실제 물리 주소를 얻어 메모리에 접근했지만 원하는 페이지가 실제 메모리에 적재되어 있지 않는 것을 말합니다. 가상 메모리를 사용하고 있기 때문에 일부만 실제 메모리에 올리고 나머지는 보조 기억 장치에 저장하고 있기 때문에 발생합니다. 페이지 폴트가 발생하면 보조 기억장치에서 필요한 페이지를 가져오게 되는데, 보조 기억장치는 메모리보다 속도가 느리기 때문에 CPU의 효율성을 낮추게 됩니다.
</br></br>

# 파이프 라인

#### 😎 파이프 라인 에 대해 설명 해주세요.

- CPU 의 성능을 높이기 위한 방법으로 제시된 병렬처리 방법중 하나이다. 명령어를 겹쳐서 실행하는 방법으로 하나의 코에 여러개의 스레드를 실행하는 방식이다.
- 명령어 처리의 단계마다 독립적으로 구성하여 각 단계가 쉬지 않고 명령어 처리한다.
- 파이프 라인 에서 Task 를 처리하는데 소요 되는시간은 다음과 같이 계산된다.

  - 수행 되는 방법의 예시
    |클럭사이클수| 1 | 2 | 3 | 4 | 5 |
    |------------|---|---|---|---|---|
    |세크먼트 1 | T1| T2| T3| T4| T5|
    |세그먼트 2 | | T1| T2| T3| T4|
    |세그먼트 3 | | | T1| T2| T3|

  - S 세그먼트 에서 N개의 task 를 마무리하기 위해서는
  - T 한개의 task 가 완료되는데 걸리는시간
  - S(T) + (N-1)*(T) => (S+N-1)*T => S+N-1

- 그러나 현실적으로 위와같은 수행시간을 보장할수 없다. 각 세그먼트 단위 마다 완료되는 시간을 정확하게 보장할수 없다.
